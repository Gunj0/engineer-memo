# デザインパターン

## デザインパターンとは

- オブジェクト指向における解決策を再利用するためのパターン
  - 原著: GoF 本 (Gang of Four), 23 パターン
    - 言語の進化により不要になったものもある

## 生成に関するパターン

### Singleton

- 基本
  - インスタンスを 1 つだけに限定する
- 詳細
  - GoF 本の方法
    - コンストラクタを private にして外部からは new できないようにする
    - 自身のインスタンスを格納する private static 変数を定義する
    - static GetInstance メソッドで、インスタンスがなければ new して private 変数に格納し、これを返す
  - プロパティに代入する方法
    - コンストラクタを private にして外部からは new できないようにする
    - Instance プロパティに自身のインスタンスを格納し、getter のみ設定する
  - static クラスを使う方法
    - class 自体を static にするとただ 1 つだけになる
    - 継承はできないので注意
    - 単体テストでは[TestInitialize]を使用して値をリセットするとよい
- メリット
  - 1 つしか存在してほしくないインスタンスを 1 つに限定できる

### Simple Factory

- 基本
  - ※
- 詳細
- メリット

### Abstract Factory

- 基本
- 詳細
- メリット

### Factory Method

- 基本
- 詳細
- メリット

### Builder

### Prototype

## 構造に関するパターン

### Facade: 建物の正面, 窓口

- 基本
  - クライアント側からサブシステムへの窓口となる統一インターフェースを定義する
- 詳細
  - static の ProjectFacade クラスを定義する(Service 等)
    - Interface を噛ませてクライアントからこれを参照すれば、Facade の入れ替えも容易になる
  - 各サブシステムを new して返すメソッドを定義する
  - 各サブシステムは基本的に internal にして、Facade, Entity, Dto だけを public にする
- メリット
  - クライアント側からどの処理を使えばいいか分かりやすくなる
    - 不要なアクセスをさせないようにできる
    - サブシステムの使い方のメモ・説明書にもなる
  - 使う際の知識を集約できる, 一連の手順を吸収できる

### Adapter: 規格の変換

- 基本
  - 変更できない・したくないオブジェクトの規格を、求めるインターフェースに変換する
- 詳細
  - Object Adapter パターン: コンポジション(has-a)【推奨】
    - ターゲットインターフェースを実装した Adapter クラスの中で Adaptee をインスタンス化して返す
  - Class Adapter パターン: 継承(is-a)
    - ターゲットインターフェースを実装して Adaptee を継承した状態で機能を返す
    - 二重継承の場合は使用できない。GoF 本でも非推奨。
- メリット
  - 元のファイル・クライアント側を変更せずに規格を統一して使用できる
    - 元のファイルのテストをする必要がなくなる

### Composite: 階層構造

- 基本
  - 親と子を同一視して階層構造を実装する
  - 容器と中身を同一視して再帰的な構造の扱いを容易にする
- 詳細
  - File も Folder も、Execute メソッドを持つ Interface/抽象クラス を実装する
  - Folder はこの Interface/抽象クラスの集約
- メリット
  - 親と子を同一視するのでクライアント側が簡潔になる
  - 階層が増えても変更が楽になる

### Bridge

### Decorator

### Flyweight

### Proxy

## 振る舞いに関するパターン

### Observer: 変化の通知

- 基本
  - オブジェクトの状態変化が自動的に他のオブジェクトに通知されるようにする
- 詳細
  - GoF 本の方法
    - `Update(bool isWarning)` メソッドを持つ INotify インターフェース を作る
    - 通知する側は`List<INotify>`のリストを持つ
      - Add メソッドでリストの中に、受け取った INotify 型のオブジェクトを追加する
      - Remove メソッドでリストの中から、受け取った INotify 型のオブジェクトを削除する
      - 通知するときは、List の中身に対して Update を実行する
    - 通知される側は`INotify`を実装する
      - 通知する側の`Add(this)`で自身のインスタンスを登録する
      - `Update(bool isWarning)`メソッドを実装して通知されたときの処理を書く
  - C# の方法
    - `public static event Action<bool> WarningAction` のようにイベントを宣言する
      - `event`をつけておくとカプセル化され、代入はできなくなる
    - 値が変わったときの処理に`WarningAction?.Invoke(value)`を書き、値の受け渡し設定をする
    - 起動処理に`WarningAction += WarningTimer_WarningAction`としてイベント処理を登録する
    - `private void WarningTimer_WarningAction(bool inWarning)`の中に、通知されたときの処理を書く
    - event は追加すると画面を閉じても残ってしまうので、Dispose 処理の中で`-=`で削除する
- メリット
  - 監視する側から監視される側を定期的に見に行く無駄な処理が不要になる

### Strategy

- 基本
- 詳細
- メリット

### Template Method

- 基本
- 詳細
- メリット

### Chain of Responsibility

### Command

### Interpreter

### Iterator

### Mediator

### Memento

### State

### Visitor
