# SOLID 原則

- オブジェクト指向の 5 大原則
  - ドメイン駆動開発の基礎

## 単一責任の原則: Single Responsibility Principle

- 基本
  - クラスの責務, 変更する理由は 1 つであるべし
    - キーワード：最小カプセル
- 詳細
  - 登場人物に合わせた最小カプセルでモデリングする
  - これ以上分割すると制御できなくなる, 一言で説明できる単位にする
    - 例：タイマーインスタンス+スタートメソッド+ストップメソッド
    - 例：「〜するクラス」と言える状態
  - データを誰が持つか, その人がその振る舞いをするべきかを考える
- メリット
  - 修正箇所が最小になる, 修正箇所が明確になる

## オープン・クローズドの原則: Open-Closed Principle

- 基本
  - 機能拡張は既存プログラムをいじらずにできるべし
  - 修正は既存プログラム内だけでできるべし
    - キーワード：拡張ポイント
- 詳細
  - Client からは拡張ポイントを使い, それを実装した旧機能と新機能を使う
    - 拡張ポイントが Interface だと GoF の Strategy パターン
    - 拡張ポイントが Abstract クラスだと GoF の Template パターン
    - 拡張ポイントが Virtual メソッド(実装があるクラスを継承すること)は非推奨
  - 新旧の判断は、Factory クラスの Create メソッド等で行う
  - Client 側で使い分けが必要ないようにする
- メリット
  - 既存プログラムをいじらないのでデグレが起こりにくい
  - 既存プログラムの中だけで修正できる

## リスコフの置換原則: Liskov Substitution Principle

- 基本
  - サブクラスは基底クラスで置換可能であるべし
    - キーワード：継承の警鐘
- 詳細
  - 基底クラスにすべて定義があり, サブクラスは一部を上書きする
  - サブクラスだけにある定義があってはならない
  - クライアント側では基本的に基底クラスに対してコーディングする
    - サブクラスは Internal にしておけばクライアントから使えなくなる
    - ただし、共通ロジックを持たせたい入力ボックス等はサブクラスを使ってもよい
  - 共通ロジックをまとめたい場合
    - ✗ 継承する → 不要な機能も継承されるし、クライアント側から見えてしまう
    - △ static な Utility を作る → 存在を知らないと使えなくなる
    - ◯ 片方が片方のクラスをインスタンス化して持つ → 全ての機能が必要ならこれ
    - ◎ 最小カプセル化を再検討する → 必要なクラスでインスタンス化すればよい
- メリット
  - Client 側で条件分岐などで使い分ける必要がない

## インタフェース分離の原則: Interface Segregation Principle

- 基本
  - クライアントが使用しないメソッドへ依存しないようにすべし
    - キーワード：ロールとしてのインターフェース
- 詳細
  - 未実装なメソッドがあるインターフェースになった場合は分けることを考える
    - 余計な処理があるインターフェース = Fat インターフェース
  - 役割・ロール（やりたいこと・できること）に応じてインターフェースを分けるとよい
- メリット
  - 不要な処理まで実装する必要がなくなる
  - 処理が明快になる

## 依存関係逆転の原則: Dependency Inversion Principle

- 基本
  - 上位モジュールは下位モジュールに依存せず、どちらも抽象に依存すべし
  - 抽象は詳細に依存せず、詳細が抽象に依存すべし
    - キーワード：依存性の注入
- 詳細
  - ロジック側がなくなったらクライアント側が動かない場合、依存している状態
  - クライアント側からは抽象クラスのみに依存するようにする
    - 抽象クラスの中身は、Factory クラスで生成する(static Factories.CreateProduct)
    - 方法 1. クライアント側の private 変数で抽象クラスを生成するようにする
    - 方法 2. DI: Dependency Injection ツールを使用する
      - クライアント側のコンストラクタの引数に実装クラスを渡すようにしておく
      - → Mock 等で自動テストがしやすくなる
- メリット
  - 抽象クラスに要求概念が集まり、仕様変更があったら実装クラスに強制することができる
  - モックを仕様したテストが容易になる

## 参考

- [オブジェクト指向の原則１：単一責務の原則とオープンクローズドの原則](https://yayoi-kkjp.udemy.com/course/objectfive1/)
- オブジェクト指向の原則２：リスコフの置換原則と継承以外の解決方法
- オブジェクト指向の原則３：依存関係逆転の原則とインタフェース分離の原則
