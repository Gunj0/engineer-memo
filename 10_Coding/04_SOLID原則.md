# SOLID 原則

- オブジェクト指向の 5 大原則
  - ドメイン駆動開発の基礎

## 単一責任の原則: Single Responsibility Principle

- 基本
  - クラスの責務, 変更する理由は 1 つであるべし
- 詳細
  - 登場人物に合わせた最小カプセルでモデリングする
  - これ以上分割すると制御できなくなる, 一言で説明できる単位にする
    - 例：タイマーインスタンス+スタートメソッド+ストップメソッド
    - 例：「〜するクラス」と言える状態
  - データを誰が持つか, その人がその振る舞いをするべきかを考える
- メリット
  - 修正箇所が最小になる, 修正箇所が明確になる

## オープン・クローズドの原則: Open-Closed Principle

- 基本
  - 機能拡張は既存プログラムをいじらずにできるべし
  - 修正は既存プログラム内だけでできるべし
- 詳細
  - Client からは拡張ポイントを使い, それを実装した旧機能と新機能を使う
    - 拡張ポイントが Interface だと GoF の Strategy パターン
    - 拡張ポイントが Abstract クラスだと GoF の Template パターン
    - 拡張ポイントが Virtual メソッド(実装があるクラスを継承すること)は非推奨
  - 新旧の判断は、Factory クラスの Create メソッド等で行う
  - Client 側で使い分けが必要ないようにする
- メリット
  - 既存プログラムをいじらないのでデグレが起こりにくい
  - 既存プログラムの中だけで修正できる

## リスコフの置換原則: Liskov Substitution Principle

- 基本
  - サブクラスは基底クラスで置換可能であるべし
- 詳細
  - 基底クラスにすべて定義があり, サブクラスは一部を上書きする
  - サブクラスだけにある定義があってはならない
  - 共通ロジックをまとめたい場合
    - ✗ 継承する → 不要な機能も継承され、クライアント側から見えてしまう
    - △Utility を作る → 存在を知らないと使えなくなる
    - ◯ 片方が片方のクラスをインスタンス化する → 不要な機能は持ってしまう
    - ◎ 最小カプセル化を再検討する → 必要なクラスでインスタンス化すればよい
- メリット
  - Client 側で条件分岐などで使い分ける必要がない

## インタフェース分離の原則: Interface Segregation Principle

- 基本
- 詳細
- メリット

## 依存関係逆転の原則: Dependency Inversion Principle

- 基本
- 詳細
- メリット
