# デザインパターン

## デザインパターンとは

- オブジェクト指向における解決策を再利用するためのパターン
  - 原著: GoF 本 (Gang of Four), 23 パターン
    - 言語の進化により不要になったものもある

## 生成に関するパターン

### Singleton

- 基本
  - インスタンスを 1 つだけに限定する
- 詳細
  - GoF 本の方法
    - コンストラクタを private にして外部からは new できないようにする
    - 自身のインスタンスを格納する private static 変数を定義する
    - static GetInstance メソッドで、インスタンスがなければ new して private 変数に格納し、これを返す
  - プロパティに代入する方法
    - コンストラクタを private にして外部からは new できないようにする
    - Instance プロパティに自身のインスタンスを格納し、getter のみ設定する
  - static クラスを使う方法
    - class 自体を static にするとただ 1 つだけになる
    - 継承はできないので注意
    - 単体テストでは`[TestInitialize]`を使用して値をリセットするとよい
- メリット
  - 1 つしか存在してほしくないインスタンスを 1 つに限定できる

### Simple Factory(GoF にはない): 1 つのクラスを差し替える方法

- 基本
  - 1 つのクラスだけを簡単に切り替える
- 詳細
  - static な`Factories`クラスと`CreateProduct`メソッドを作り`kind`引数に応じて `IProduct` を実装したクラスを返す
  - クライアント側では`CreateProduct`で帰ってきた`IProduct`に対して処理を書く
  - コンストラクタで`IProduct`を依存性注入するようにすると、Mock に差し替えられるのでテスト容易性が上がる。
- メリット
  - 切り替えたいクラスが増えてもクライアント側は変えなくて良い
  - シンプルで分かりやすい記述になる

### Abstract Factory: 複数の Factory をまとめて差し替える方法

- 基本
  - 互いに関連するオブジェクト郡をその具象クラスを明確にせず生成するためのインターフェース
- 詳細
  - `AbstractFactory`クラスの中で`CreateProduct`メソッドと`CreateStock`メソッドを定義する
  - これを継承した`FakeFactory`と`SqlServerFactory`の中で各メソッドの生成するクラスを書く
  - `AbstractFactory`で`Create`メソッドを定義し、`Kind`引数に応じて生成する Factory を切り替える
- メリット
  - まとめて差し替えられるので差し替え漏れがない
  - if 文が全体で一つだけになりミスしづらくなる
  - Factory の種類ごとにグルーピングできる

### Factory Method: サブクラスにインスタンスを生成させて共通ロジックを書く方法

- 基本
  - オブジェクト生成のインターフェースだけを規定して、サブクラスが実際にどのクラスをインスタンス化するか決める
- 詳細
  - `ProductService`抽象クラスに`Create`メソッドと`FactoryMethod`メソッドを定義する, これを Creator クラスと呼ぶ
  - これを継承した`ProductServiceFactory`の中で`Kind`を引数に`IProduct`を返す`FactoryMethod`の処理を書く
  - Creator 側の`Create`メソッドでは`FactoryMethod`で生成した`IProduct`に対する共通ロジックで処理して`IProduct`を返す
  - クライアント側では`ProductServiceFactory`の`Create`を呼ぶことで共通ロジックを通してクラス生成ができる
- メリット
  - Factory に共通ロジックを持たせられる

### Builder

- 基本
- 詳細
- メリット

### Prototype

- 基本
- 詳細
- メリット

## 構造に関するパターン

### Facade: 建物の正面, 窓口

- 基本
  - クライアント側からサブシステムへの窓口となる統一インターフェースを定義する
- 詳細
  - static の ProjectFacade クラスを定義する(Service 等)
    - Interface を噛ませてクライアントからこれを参照すれば、Facade の入れ替えも容易になる
  - 各サブシステムを new して返すメソッドを定義する
  - 各サブシステムは基本的に internal にして、Facade, Entity, Dto だけを public にする
- メリット
  - クライアント側からどの処理を使えばいいか分かりやすくなる
    - 不要なアクセスをさせないようにできる
    - サブシステムの使い方のメモ・説明書にもなる
  - 使う際の知識を集約できる, 一連の手順を吸収できる

### Adapter: 規格の変換

- 基本
  - 変更できない・したくないオブジェクトの規格を、求めるインターフェースに変換する
- 詳細
  - Object Adapter パターン: コンポジション(has-a)【推奨】
    - ターゲットインターフェースを実装した Adapter クラスの中で Adaptee をインスタンス化して返す
  - Class Adapter パターン: 継承(is-a)
    - ターゲットインターフェースを実装して Adaptee を継承した状態で機能を返す
    - 二重継承の場合は使用できない。GoF 本でも非推奨。
- メリット
  - 元のファイル・クライアント側を変更せずに規格を統一して使用できる
    - 元のファイルのテストをする必要がなくなる

### Composite: 階層構造

- 基本
  - 親と子を同一視して階層構造を実装する
  - 容器と中身を同一視して再帰的な構造の扱いを統一にする
- 詳細
  - `Execute` メソッドを持つ部品クラスを Interface/抽象クラスで定義する
  - 部品クラスを実装/継承する `Folder` クラス と `File` クラスを定義する
  - Folder クラスには部品クラスの `List` をもたせ、`Add` メソッドで `List` に部品を追加できるようにする
  - リスコフの置換原則に従い、部品クラスと`File` クラスにも `Add` メソッドをもたせ、例外を投げるようにする
  - `GetChildren`メソッド等を `Folder` クラスに作り`List` を返すようにしておくことでクライアント側で再帰的な処理ができる
  - `Folder` クラス と `File` クラス以外にも、バリエーションを作ることもできる
- メリット
  - 親と子を同一視するのでクライアント側が簡潔になる
  - 階層が増えても変更が楽になる

### Bridge

- 基本
- 詳細
- メリット

### Decorator

- 基本
- 詳細
- メリット

### Flyweight

- 基本
- 詳細
- メリット

### Proxy

- 基本
- 詳細
- メリット

## 振る舞いに関するパターン

### Observer: 変化の通知

- 基本
  - オブジェクトの状態変化が自動的に他のオブジェクトに通知されるようにする
- 詳細
  - GoF 本の方法
    - `Update(bool isWarning)` メソッドを持つ INotify インターフェース を作る
    - 通知する側は`List<INotify>`のリストを持つ
      - Add メソッドでリストの中に、受け取った INotify 型のオブジェクトを追加する
      - Remove メソッドでリストの中から、受け取った INotify 型のオブジェクトを削除する
      - 通知するときは、List の中身に対して Update を実行する
    - 通知される側は`INotify`を実装する
      - 通知する側の`Add(this)`で自身のインスタンスを登録する
      - `Update(bool isWarning)`メソッドを実装して通知されたときの処理を書く
  - C# の方法
    - `public static event Action<bool> WarningAction` のようにイベントを宣言する
      - `event`をつけておくとカプセル化され、代入はできなくなる
    - 値が変わったときの処理に`WarningAction?.Invoke(value)`を書き、値の受け渡し設定をする
    - 起動処理に`WarningAction += WarningTimer_WarningAction`としてイベント処理を登録する
    - `private void WarningTimer_WarningAction(bool inWarning)`の中に、通知されたときの処理を書く
    - event は追加すると画面を閉じても残ってしまうので、Dispose 処理の中で`-=`で削除する
- メリット
  - 監視する側から監視される側を定期的に見に行く無駄な処理が不要になる

### Strategy

- 基本
- 詳細
- メリット

### Template Method

- 基本
- 詳細
- メリット

### Chain of Responsibility

- 基本
- 詳細
- メリット

### Command

- 基本
- 詳細
- メリット

### Interpreter

- 基本
- 詳細
- メリット

### Iterator

- 基本
- 詳細
- メリット

### Mediator

- 基本
- 詳細
- メリット

### Memento

- 基本
- 詳細
- メリット

### State

- 基本
- 詳細
- メリット

### Visitor

- 基本
- 詳細
- メリット
